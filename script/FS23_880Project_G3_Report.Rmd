---
title: "GEO880-G3-Report"
author: "Martine Besse & Yelu He"
date: "2023-06-15"
always_allow_html: true
output:
  html_document:
    code_folding: hide
    fig_caption: yes
    number_sections: no
    toc: yes
    toc_depth: 3
    toc_float: yes
  pdf_document:
    toc: yes
    toc_depth: '3'
---

```{r initialisation, warning = FALSE, message = FALSE}
# initialisation code copied on file GEO872-session-01-solution.rmd

# packages:

## Default repository
local({r <- getOption("repos")
       r["CRAN"] <- "http://cran.r-project.org" 
       options(repos=r)
})

check_pkg <- function(x)
  {
    if (!require(x,character.only = TRUE, quietly = TRUE))
    {
      install.packages(x,dep=TRUE)
        if(!require(x,character.only = TRUE, quietly = TRUE)) stop("Package not found")
    }
}

# Call check_pkg() to install/load the required packages. 
check_pkg("here")
check_pkg("sf")
check_pkg("readr") 
check_pkg("ggplot2")
check_pkg("dplyr")
check_pkg("lubridate") #for timezones
check_pkg("raster")
check_pkg("leaflet")
#https://github.com/benmarwick/wordcountaddin
#check_pkg("wordcountaddin") -> ma: does not work on my computer :(


#DATA FOLDER
#On Martine laptop:
data_folder <- "D:/Documents/Master/UZH/cours/GEO880_Computational Movement Analysis/Project/FS23_880Project_G3/script/data"
#On Yelu laptop:
#data_folder <- "D:/GEO880/Project"
```

# Criteria:
length: 30'000 - 50'000  
Report your work in a written project report. The report has two functions:  
– It shall serve you as documentation of what you did, such that at a later stage you can use the report in one of your own projects.  
– It will be used to evaluate and mark your project.

Your report shall:
– cover how you went about investigating your research questions. Describe your data science ideas and how you implemented your ideas.
– present the results of your study and discuss them in the light of your research questions. What have you achieved and what would be further steps for future research?
– report problems and limitations you encountered along the way and the solutions you chose to overcome these, be it limitations with respect to the data sources, the tools or any other source of limitation.
– discuss your data science choices in the light of the theory covered in the lectures, group works, and your reading assignments.

Good example: https://fbilan.github.io/GEO880_2020/Project_GEO880_Wysling_Biland.html

# Introduction
## Research questions
1. Do the characteristics of movement trajectories differ beetween different travel modes?
2. Could the characteristics be used to identify travel mode?
3. How to identify different travel modes with movement trajectories? Could a identification model be built?
4. How accurate and efficient could different travel modes be identified based on the aforementioned identification model?

## Background
Literature review
- list of travel modes considered in our study.
- characteristics specific to the mean of transport

# Methodology
First the trajectories data will be prepared to be fed for machine learning: data cleaning, labelizing, values extracted.

Labels list: boat, train, etc.

## Preprocessing of trajectories data
### Posmo data
- clean GPS data and add basic common columns attributes
- labelize data
- overview (here or maybe later?)
...

#### Import, clean posmo data
```{r}
#import and convert to sf object

# working on Matine's laptop
posmo <- read_csv(here(data_folder, "posmo_2023-06-14_2.csv")) %>% st_as_sf(coords = c("lon_x", "lat_y"), crs=4326, remove = FALSE) |> st_transform(2056)

# working on Yelu's laptop
#posmo <- read_csv(here(data_folder, "posmo_2023-06-14_2.csv")) %>% st_as_sf(coords = c("lon_x", "lat_y"), crs=4326, remove = FALSE) |> st_transform(2056)

#clean and add columns
posmo$source <- "posmo"

posmo <- posmo %>% 
       rename("tmode_posmo" = "transport_mode")

posmo$tmode_manual <- NA

to_remove <- c("place_name", "lon_x", "lat_y", "user_id")
posmo <- posmo[ , !(names(posmo) %in% to_remove)]

#add East and North columns
coords <- posmo |> st_coordinates()
posmo <- posmo |> 
  mutate(E =  coords[,1], N = coords[,2])

#update timezone
posmo <- posmo %>%
  mutate(
    datetime = datetime %>% with_tz(tzone = "Europe/Zurich")
  )

# Add heights
# The height comes from the Digital height model DHM25 provided by swisstopo. The raster has been preprocessed on QGIS to be converted into the epsg 2056 (previously 21781) to save calculation time.
# The resolution is 25m. To have more precise information, we could look at the swiss3DAlti if needed.  
# Simplification: we did not consider height of soil compared to height of person or public transport.  
# As it is a relative variable to calculate slope, it does not matter.

#Extract values from rasters:
#https://gisday.wordpress.com/2014/03/24/extract-raster-values-from-points-using-r/comment-page-1/

# On martine's laptop
dhm25 <- raster(here(data_folder, "dhm25_raster", "dhm25_2056.tif"))
# On yelu's laptop
#dhm25 <- raster(here(data_folder, "dhm25_raster", "dhm25_2056.tif"))

rasValue <- extract(dhm25, posmo)
posmo$H <- rasValue

# #Adapt column order
# col_order <- c("source", "datetime", "weekday", "tmode_posmo", "tmode_manual" ,"E", "N", "H", "timelag", "steplength_m", "speed_ms", "slope", "geometry")
# posmo <- posmo[, col_order]
# posmo
```

#### Labelize posmo data

```{r}
#select segments
condition_boats <- posmo$datetime > as.POSIXct("2023-05-14 13:55:00", tz = "Europe/Zurich") & posmo$datetime < as.POSIXct("2023-05-14 14:21:00", tz = "Europe/Zurich")

condition_cable_cars <- 
  posmo$datetime > as.POSIXct("2023-04-12 09:12:00", tz = "Europe/Zurich") & posmo$datetime < as.POSIXct("2023-04-12 09:18:30", tz = "Europe/Zurich")

condition_ski_lifts <- 
  posmo$datetime > as.POSIXct("2023-04-12 09:23:00", tz = "Europe/Zurich") & posmo$datetime < as.POSIXct("2023-04-12 09:30:00", tz = "Europe/Zurich") |
  posmo$datetime > as.POSIXct("2023-04-12 09:33:00", tz = "Europe/Zurich") & posmo$datetime < as.POSIXct("2023-04-12 09:41:00", tz = "Europe/Zurich") |
  posmo$datetime > as.POSIXct("2023-04-12 09:51:00", tz = "Europe/Zurich") & posmo$datetime < as.POSIXct("2023-04-12 9:59:00", tz = "Europe/Zurich") |
  posmo$datetime > as.POSIXct("2023-04-12 10:15:00", tz = "Europe/Zurich") & posmo$datetime < as.POSIXct("2023-04-12 10:24:00", tz = "Europe/Zurich") |
  posmo$datetime > as.POSIXct("2023-04-12 10:51:30", tz = "Europe/Zurich") & posmo$datetime < as.POSIXct("2023-04-12 10:57:30", tz = "Europe/Zurich") |
  posmo$datetime > as.POSIXct("2023-04-12 11:00:00", tz = "Europe/Zurich") & posmo$datetime < as.POSIXct("2023-04-12 11:08:00", tz = "Europe/Zurich") |
  posmo$datetime > as.POSIXct("2023-04-12 11:21:30", tz = "Europe/Zurich") & posmo$datetime < as.POSIXct("2023-04-12 11:29:00", tz = "Europe/Zurich") |
  posmo$datetime > as.POSIXct("2023-04-12 11:46:00", tz = "Europe/Zurich") & posmo$datetime < as.POSIXct("2023-04-12 11:51:30", tz = "Europe/Zurich") |
  posmo$datetime > as.POSIXct("2023-04-12 13:49:30", tz = "Europe/Zurich") & posmo$datetime < as.POSIXct("2023-04-12 13:54:00", tz = "Europe/Zurich") |
  posmo$datetime > as.POSIXct("2023-04-12 13:57:00", tz = "Europe/Zurich") & posmo$datetime < as.POSIXct("2023-04-12 14:05:00", tz = "Europe/Zurich")

condition_t_bars <- 
  posmo$datetime > as.POSIXct("2023-04-12 10:28:00", tz = "Europe/Zurich") & posmo$datetime < as.POSIXct("2023-04-12 10:33:00", tz = "Europe/Zurich") |
  posmo$datetime > as.POSIXct("2023-04-12 14:10:00", tz = "Europe/Zurich") & posmo$datetime < as.POSIXct("2023-04-12 14:18:00", tz = "Europe/Zurich") 

condition_skis <- 
  posmo$datetime > as.POSIXct("2023-04-12 09:30:00", tz = "Europe/Zurich") & posmo$datetime < as.POSIXct("2023-04-12 09:33:00", tz = "Europe/Zurich") |
  posmo$datetime > as.POSIXct("2023-04-12 09:41:00", tz = "Europe/Zurich") & posmo$datetime < as.POSIXct("2023-04-12 9:51:00", tz = "Europe/Zurich") |
  posmo$datetime > as.POSIXct("2023-04-12 09:59:00", tz = "Europe/Zurich") & posmo$datetime < as.POSIXct("2023-04-12 10:15:00", tz = "Europe/Zurich") |
  posmo$datetime > as.POSIXct("2023-04-12 10:24:00", tz = "Europe/Zurich") & posmo$datetime < as.POSIXct("2023-04-12 10:28:00", tz = "Europe/Zurich") |
  posmo$datetime > as.POSIXct("2023-04-12 10:33:00", tz = "Europe/Zurich") & posmo$datetime < as.POSIXct("2023-04-12 10:51:30", tz = "Europe/Zurich") |
  posmo$datetime > as.POSIXct("2023-04-12 10:57:30", tz = "Europe/Zurich") & posmo$datetime < as.POSIXct("2023-04-12 11:00:00", tz = "Europe/Zurich") |
  posmo$datetime > as.POSIXct("2023-04-12 11:08:00", tz = "Europe/Zurich") & posmo$datetime < as.POSIXct("2023-04-12 11:21:30", tz = "Europe/Zurich") |
  posmo$datetime > as.POSIXct("2023-04-12 11:29:00", tz = "Europe/Zurich") & posmo$datetime < as.POSIXct("2023-04-12 11:46:00", tz = "Europe/Zurich") |
  posmo$datetime > as.POSIXct("2023-04-12 11:51:30", tz = "Europe/Zurich") & posmo$datetime < as.POSIXct("2023-04-12 13:49:30", tz = "Europe/Zurich") |
  posmo$datetime > as.POSIXct("2023-04-12 13:54:00", tz = "Europe/Zurich") & posmo$datetime < as.POSIXct("2023-04-12 13:57:00", tz = "Europe/Zurich") |
  posmo$datetime > as.POSIXct("2023-04-12 14:05:00", tz = "Europe/Zurich") & posmo$datetime < as.POSIXct("2023-04-12 14:10:00", tz = "Europe/Zurich") |
  posmo$datetime > as.POSIXct("2023-04-12 14:18:00", tz = "Europe/Zurich") & posmo$datetime < as.POSIXct("2023-04-12 14:48:00", tz = "Europe/Zurich") 

condition_scooters <- 
  posmo$datetime > as.POSIXct("2023-05-04 07:36:00", tz = "Europe/Zurich") & posmo$datetime < as.POSIXct("2023-05-04 07:42:00", tz = "Europe/Zurich") |
  posmo$datetime > as.POSIXct("2023-05-24 22:00:00", tz = "Europe/Zurich") & posmo$datetime < as.POSIXct("2023-05-24 22:10:00", tz = "Europe/Zurich") |
  posmo$datetime > as.POSIXct("2023-05-24 19:48:00", tz = "Europe/Zurich") & posmo$datetime < as.POSIXct("2023-05-24 20:00:00", tz = "Europe/Zurich")

condition_bikes <- 
  posmo$datetime > as.POSIXct("2023-05-02 08:31:00", tz = "Europe/Zurich") & posmo$datetime < as.POSIXct("2023-05-02 08:36:00", tz = "Europe/Zurich") |
  posmo$datetime > as.POSIXct("2023-05-02 11:49:00", tz = "Europe/Zurich") & posmo$datetime < as.POSIXct("2023-05-02 12:04:00", tz = "Europe/Zurich") |
  posmo$datetime > as.POSIXct("2023-05-02 17:44:00", tz = "Europe/Zurich") & posmo$datetime < as.POSIXct("2023-05-02 18:04:00", tz = "Europe/Zurich") |
  posmo$datetime > as.POSIXct("2023-05-15 15:57:00", tz = "Europe/Zurich") & posmo$datetime < as.POSIXct("2023-05-15 16:32:00", tz = "Europe/Zurich") 

condition_trains <- 
  posmo$datetime > as.POSIXct("2023-03-30 17:00:00", tz = "Europe/Zurich") & posmo$datetime < as.POSIXct("2023-03-30 17:52:00", tz = "Europe/Zurich") | 
  posmo$datetime > as.POSIXct("2023-05-26 18:10:00", tz = "Europe/Zurich") & posmo$datetime < as.POSIXct("2023-05-26 19:15:00", tz = "Europe/Zurich") | 
  posmo$datetime > as.POSIXct("2023-05-09 8:40:00", tz = "Europe/Zurich") & posmo$datetime < as.POSIXct("2023-05-09 10:55:00", tz = "Europe/Zurich") | 
  posmo$datetime > as.POSIXct("2023-04-28 12:20:00", tz = "Europe/Zurich") & posmo$datetime < as.POSIXct("2023-04-28 12:50:00", tz = "Europe/Zurich") | 
  posmo$datetime > as.POSIXct("2023-06-09 19:30:00", tz = "Europe/Zurich") & posmo$datetime < as.POSIXct("2023-06-09 21:30:00", tz = "Europe/Zurich") |
  posmo$datetime > as.POSIXct("2023-04-03 22:15:00", tz = "Europe/Zurich") & posmo$datetime < as.POSIXct("2023-04-04 00:22:00", tz = "Europe/Zurich") |
  posmo$datetime > as.POSIXct("2023-06-09 12:23:00", tz = "Europe/Zurich") & posmo$datetime < as.POSIXct("2023-06-09 12:48:00", tz = "Europe/Zurich") |
  posmo$datetime > as.POSIXct("2023-06-11 02:30:00", tz = "Europe/Zurich") & posmo$datetime < as.POSIXct("2023-06-11 02:45:00", tz = "Europe/Zurich") |
  posmo$datetime > as.POSIXct("2023-06-12 07:00:00", tz = "Europe/Zurich") & posmo$datetime < as.POSIXct("2023-06-12 07:53:00", tz = "Europe/Zurich") | 
  posmo$datetime > as.POSIXct("2023-06-14 17:25:00", tz = "Europe/Zurich") & posmo$datetime < as.POSIXct("2023-06-14 17:42:00", tz = "Europe/Zurich") |
  posmo$datetime > as.POSIXct("2023-06-06 09:05:00", tz = "Europe/Zurich") & posmo$datetime < as.POSIXct("2023-06-06 11:00:00", tz = "Europe/Zurich")

condition_trams <- 
  posmo$datetime > as.POSIXct("2023-04-16 15:30:00", tz = "Europe/Zurich") & posmo$datetime < as.POSIXct("2023-04-16 15:37:00", tz = "Europe/Zurich") | 
  posmo$datetime > as.POSIXct("2023-06-09 17:17:00", tz = "Europe/Zurich") & posmo$datetime < as.POSIXct("2023-06-09 17:22:00", tz = "Europe/Zurich") |
  posmo$datetime > as.POSIXct("2023-06-09 13:40:00", tz = "Europe/Zurich") & posmo$datetime < as.POSIXct("2023-06-09 13:54:00", tz = "Europe/Zurich") |
  posmo$datetime > as.POSIXct("2023-06-06 11:09:00", tz = "Europe/Zurich") & posmo$datetime < as.POSIXct("2023-06-06 11:23:00", tz = "Europe/Zurich") |
  posmo$datetime > as.POSIXct("2023-06-05 18:49:00", tz = "Europe/Zurich") & posmo$datetime < as.POSIXct("2023-06-05 19:03:00", tz = "Europe/Zurich") |
  posmo$datetime > as.POSIXct("2023-06-05 23:33:00", tz = "Europe/Zurich") & posmo$datetime < as.POSIXct("2023-06-05 23:40:00", tz = "Europe/Zurich") |
  posmo$datetime > as.POSIXct("2023-04-25 15:50:00", tz = "Europe/Zurich") & posmo$datetime < as.POSIXct("2023-04-25 15:57:00", tz = "Europe/Zurich")

condition_bus <- 
  posmo$datetime > as.POSIXct("2023-06-09 17:25:00", tz = "Europe/Zurich") & posmo$datetime < as.POSIXct("2023-06-09 17:31:00", tz = "Europe/Zurich") |
  posmo$datetime > as.POSIXct("2023-05-24 19:32:00", tz = "Europe/Zurich") & posmo$datetime < as.POSIXct("2023-05-24 19:49:00", tz = "Europe/Zurich") |
  posmo$datetime > as.POSIXct("2023-05-24 22:10:00", tz = "Europe/Zurich") & posmo$datetime < as.POSIXct("2023-05-24 22:22:00", tz = "Europe/Zurich") |
  posmo$datetime > as.POSIXct("2023-06-07 07:53:00", tz = "Europe/Zurich") & posmo$datetime < as.POSIXct("2023-06-07 08:12:00", tz = "Europe/Zurich") | posmo$datetime > as.POSIXct("2023-06-07 08:35:00", tz = "Europe/Zurich") & posmo$datetime < as.POSIXct("2023-06-07 08:45:00", tz = "Europe/Zurich") | posmo$datetime > as.POSIXct("2023-06-07 19:23:00", tz = "Europe/Zurich") & posmo$datetime < as.POSIXct("2023-06-07 19:37:00", tz = "Europe/Zurich") |
  posmo$datetime > as.POSIXct("2023-06-06 20:39:00", tz = "Europe/Zurich") & posmo$datetime < as.POSIXct("2023-06-06 20:44:00", tz = "Europe/Zurich") |
  posmo$datetime > as.POSIXct("2023-06-06 21:03:00", tz = "Europe/Zurich") & posmo$datetime < as.POSIXct("2023-06-06 21:17:00", tz = "Europe/Zurich") |
  posmo$datetime > as.POSIXct("2023-06-06 08:15:00", tz = "Europe/Zurich") & posmo$datetime < as.POSIXct("2023-06-06 08:25:00", tz = "Europe/Zurich") |
  posmo$datetime > as.POSIXct("2023-06-06 08:28:00", tz = "Europe/Zurich") & posmo$datetime < as.POSIXct("2023-06-06 08:35:00", tz = "Europe/Zurich") |
  posmo$datetime > as.POSIXct("2023-06-05 18:37:00", tz = "Europe/Zurich") & posmo$datetime < as.POSIXct("2023-06-05 18:46:00", tz = "Europe/Zurich") |
  posmo$datetime > as.POSIXct("2023-04-25 11:36:00", tz = "Europe/Zurich") & posmo$datetime < as.POSIXct("2023-04-25 11:57:00", tz = "Europe/Zurich") |
  posmo$datetime > as.POSIXct("2023-04-25 16:33:00", tz = "Europe/Zurich") & posmo$datetime < as.POSIXct("2023-04-25 16:39:00", tz = "Europe/Zurich") 

condition_walks <- 
  posmo$datetime > as.POSIXct("2023-04-16 15:30:00", tz = "Europe/Zurich") & posmo$datetime < as.POSIXct("2023-04-16 15:37:00", tz = "Europe/Zurich") | 
  posmo$datetime > as.POSIXct("2023-04-16 15:44:00", tz = "Europe/Zurich") & posmo$datetime < as.POSIXct("2023-04-16 15:56:00", tz = "Europe/Zurich") |
  posmo$datetime > as.POSIXct("2023-05-13 13:29:00", tz = "Europe/Zurich") & posmo$datetime < as.POSIXct("2023-05-13 15:01:00", tz = "Europe/Zurich") |
  posmo$datetime > as.POSIXct("2023-05-13 16:40:00", tz = "Europe/Zurich") & posmo$datetime < as.POSIXct("2023-05-13 22:01:00", tz = "Europe/Zurich") |
  posmo$datetime > as.POSIXct("2023-05-13 22:04:00", tz = "Europe/Zurich") & posmo$datetime < as.POSIXct("2023-05-13 22:29:00", tz = "Europe/Zurich") |
  posmo$datetime > as.POSIXct("2023-05-20 11:54:00", tz = "Europe/Zurich") & posmo$datetime < as.POSIXct("2023-05-20 22:35:00", tz = "Europe/Zurich") |
  posmo$datetime > as.POSIXct("2023-05-22 11:00:00", tz = "Europe/Zurich") & posmo$datetime < as.POSIXct("2023-05-22 11:42:00", tz = "Europe/Zurich") |
  posmo$datetime > as.POSIXct("2023-05-29 16:18:00", tz = "Europe/Zurich") & posmo$datetime < as.POSIXct("2023-05-29 16:46:00", tz = "Europe/Zurich") |
  posmo$datetime > as.POSIXct("2023-06-09 11:30:00", tz = "Europe/Zurich") & posmo$datetime < as.POSIXct("2023-06-09 12:20:00", tz = "Europe/Zurich") |
  posmo$datetime > as.POSIXct("2023-06-11 02:46:00", tz = "Europe/Zurich") & posmo$datetime < as.POSIXct("2023-06-11 03:04:00", tz = "Europe/Zurich") |
  posmo$datetime > as.POSIXct("2023-06-12 07:53:00", tz = "Europe/Zurich") & posmo$datetime < as.POSIXct("2023-06-12 08:07:00", tz = "Europe/Zurich") |
  posmo$datetime > as.POSIXct("2023-06-06 08:11:00", tz = "Europe/Zurich") & posmo$datetime < as.POSIXct("2023-06-06 08:15:00", tz = "Europe/Zurich") |
  posmo$datetime > as.POSIXct("2023-06-05 23:40:00", tz = "Europe/Zurich") & posmo$datetime < as.POSIXct("2023-06-05 23:57:00", tz = "Europe/Zurich") |
  posmo$datetime > as.POSIXct("2023-04-12 09:00:00", tz = "Europe/Zurich") & posmo$datetime < as.POSIXct("2023-04-12 09:12:00", tz = "Europe/Zurich") |
  posmo$datetime > as.POSIXct("2023-04-12 18:40:00", tz = "Europe/Zurich") & posmo$datetime < as.POSIXct("2023-04-12 18:50:00", tz = "Europe/Zurich") |
  posmo$datetime > as.POSIXct("2023-04-25 11:57:00", tz = "Europe/Zurich") & posmo$datetime < as.POSIXct("2023-04-25 12:05:00", tz = "Europe/Zurich") |
  posmo$datetime > as.POSIXct("2023-04-25 15:40:00", tz = "Europe/Zurich") & posmo$datetime < as.POSIXct("2023-04-25 15:50:00", tz = "Europe/Zurich") 

condition_cars <- 
  posmo$datetime > as.POSIXct("2023-06-11 15:00:00", tz = "Europe/Zurich") & posmo$datetime < as.POSIXct("2023-06-11 17:00:00", tz = "Europe/Zurich") | 
  posmo$datetime > as.POSIXct("2023-04-24 14:00:00", tz = "Europe/Zurich") & posmo$datetime < as.POSIXct("2023-04-24 17:30:00", tz = "Europe/Zurich") |
  posmo$datetime > as.POSIXct("2023-06-10 13:40:00", tz = "Europe/Zurich") & posmo$datetime < as.POSIXct("2023-06-10 17:33:00", tz = "Europe/Zurich") |
  posmo$datetime > as.POSIXct("2023-06-09 21:45:00", tz = "Europe/Zurich") & posmo$datetime < as.POSIXct("2023-06-09 22:30:00", tz = "Europe/Zurich") |
  posmo$datetime > as.POSIXct("2023-06-14 07:10:00", tz = "Europe/Zurich") & posmo$datetime < as.POSIXct("2023-06-14 08:00:00", tz = "Europe/Zurich") |
  posmo$datetime > as.POSIXct("2023-06-14 17:44:00", tz = "Europe/Zurich") & posmo$datetime < as.POSIXct("2023-06-14 18:10:00", tz = "Europe/Zurich") |
  posmo$datetime > as.POSIXct("2023-06-13 18:00:00", tz = "Europe/Zurich") & posmo$datetime < as.POSIXct("2023-06-13 19:15:00", tz = "Europe/Zurich") 

#final labelizing
posmo <- posmo %>%
  mutate(tmode_manual = case_when(condition_walks ~ 'walk',
                                  condition_boats ~ 'boat',
                                  condition_trains ~ 'train',
                                  condition_bikes ~ 'bike',
                                  condition_scooters ~ 'kick-scooter',
                                  condition_cars ~ 'car',
                                  condition_bus ~ 'bus',
                                  condition_trams ~ 'tram',
                                  condition_t_bars ~ 't_bar',
                                  condition_cable_cars ~ 'cable_car',
                                  condition_ski_lifts ~ 'ski_lift',
                                  condition_skis ~ 'ski'
                                  ))
# select columns
posmo <- dplyr::select(posmo, c("source", "datetime", "tmode_manual", "E", "N", "H", "geometry"))

```


### GPS data
- clean GPS data and have basic common columns attributes
```{r, echo = TRUE, warning = FALSE, message = FALSE}
## Load the data
# Yelu laptop
#gps_data_raw <- read_delim(here(data_folder, "yelu_dataset_0609.csv"), ";")

#Martine Laptop
gps_data_raw <- read_delim(here(data_folder, "yelu_dataset_0609.csv"), ";")

## Use right coordinate system and preserve original E/N columns
gps_data_raw <- st_as_sf(gps_data_raw, coords = c("Longitude", "Latitude"), crs = 4326, remove = FALSE)
gps_data <- gps_data_raw %>% st_transform(crs = 2056)

gps_data$Datetime <- as.POSIXct(paste(as.Date(gps_data$Date, format = '%d.%m.%Y'), gps_data$Time), format = "%Y-%m-%d %H:%M:%S", tz = "UTC")
gps_data <- gps_data %>% mutate(Datetime = Datetime %>% with_tz(tzone = "Europe/Zurich"))

gps_data$source <- "gps"


# Extract E and N values
coords <- gps_data |> st_coordinates()
gps_data <- gps_data |> 
  mutate(Latitude =  coords[,2], Longitude = coords[,1])


# Rename columns
colnames(gps_data)[11] <- "datetime"
colnames(gps_data)[3] <- "N"
colnames(gps_data)[4] <- "E"
colnames(gps_data)[8] <- "H"

colnames(gps_data)
# Add column for travel mode
gps_data$tmode_manual <- NA


gps_data <- dplyr::select(gps_data, c("source", "datetime", "N", "E", "H", "geometry", "tmode_manual"))
# dataFolder   <- here::here("D:/GEO880/Project/")
# zurich_map <- st_read(file.path(dataFolder, "stadtkreis/stadtkreis/Stadtkreis.shp"))
# zurich_map <- st_transform(zurich_map, epsg = 2056)

```


- labelize data
```{r, echo = TRUE, warning = FALSE, message = FALSE}


# Conditions for different travel modes
condition_bus <- 
  gps_data$datetime >= as.POSIXct("2023-04-21 16:18:35") & gps_data$datetime <= as.POSIXct("2023-04-21 16:23:40")

condition_tram <- 
  gps_data$datetime >= as.POSIXct("2023-04-21 17:18:55") & gps_data$datetime <= as.POSIXct("2023-04-21 17:26:05") | 
  gps_data$datetime >= as.POSIXct("2023-04-25 15:07:50") & gps_data$datetime <= as.POSIXct("2023-04-25 15:11:55") | 
  gps_data$datetime >= as.POSIXct("2023-04-25 17:40:50") & gps_data$datetime <= as.POSIXct("2023-04-25 17:47:20")

condition_walk <- 
  gps_data$datetime >= as.POSIXct("2023-04-21 16:13:40") & gps_data$datetime <= as.POSIXct("2023-04-21 16:16:25") |
  gps_data$datetime >= as.POSIXct("2023-04-25 15:37:00") & gps_data$datetime <= as.POSIXct("2023-04-25 15:40:15")
  
# Labelizing data
gps_data <- gps_data %>%
  mutate(tmode_manual = case_when(condition_walk ~ 'walk',
                                         condition_tram ~ 'tram',
                                         condition_bus ~ 'bus'
                                         #condition_boat ~ 'boat',
                                         #condition_run ~ 'run',
                                         ))

```

- overview
...

### Merge Posmo and GPS tracker
- Compute new variables: timelag, steplength, speed, acceleration, slope, etc.
- remove statics (ex.3)
- Add segment IDs (ex.3 - task 4)

```{r}
#here merge with gps tracker
mvmt_data <- rbind(posmo, gps_data)

col_order <- c("source", "datetime", "tmode_manual" ,"E", "N", "H", "geometry")
mvmt_data <- mvmt_data[, col_order]
mvmt_data

```

#### Overview of Posmo and GPS tracker datasets:

Map general overview - two users:  
```{r}
#map overview
mvmt_data_wgs <- mvmt_data %>% st_transform(crs = 4326)

m <- leaflet() %>%
  addTiles() %>%  # Add default OpenStreetMap map tiles
  addCircleMarkers(data = mvmt_data_wgs,
                   #opacity = 0.3, 
                   radius = 0.2,
                   popup = mvmt_data_wgs$datetime,
                   color = 'blue') %>%
  addLegend(position = 'topright', 
            colors = c('blue'), 
            labels = c('points'),
            title = 'All points from GPS tracker and posmo')

# Plot the leaflet object m
m


```

Map general overview - labelized segments:  
```{r}
#map overview
mvmt_data_wgs <- mvmt_data %>% st_transform(crs = 4326) %>% filter(is.na(tmode_manual) == FALSE)



# check overlapping days of labelized data
# mvmt_data_wgs %>% 
#   mutate(
#     day = format(as.POSIXct(datetime), format = "%Y-%m-%d")) %>%
#   group_by(day, source) %>% 
#   summarize(n()) %>% View()


#Palette
factpal <- colorFactor(topo.colors(2), domain =mvmt_data_wgs$source)

m <- leaflet() %>%
  addTiles() %>%  # Add default OpenStreetMap map tiles
  addCircleMarkers(data = mvmt_data_wgs,
                   #opacity = 0.3, 
                   radius = 0.2,
                   popup = mvmt_data_wgs$datetime,
                   color = ~factpal(source)) %>%
                   #color = 'blue') %>%
  addLegend(position = 'topright', 
            #colors = c('blue'), 
            #labels = c('points'),
            pal = factpal,
            values = mvmt_data_wgs$source,
            title = 'Labelized points from GPS tracker and posmo')

# Plot the leaflet object m
m


```



Map general overview - posmo user:  
...

Map general overview - GPS tracker user:  
...

Map general overview - per region (?):  
...


#### Computing trajectory derivatives
Here we will compute all necessary values to determine mean of transport: 

- speed (steplength + timelag)
- acceleration
- sinuosity
- turning angles
- slope
- (elevation speed?)
- ...
- region (mainly for visualisation)
```{r}
#compute new values
#/!\ probably have to do it by group by like in exercice 2:
# wildschwein_BE <- wildschwein_BE %>%
#   group_by(TierName) %>%
#   mutate(diff_s = as.numeric(difftime(lead(DatetimeUTC), DatetimeUTC)))

#timelag
mvmt_data <- mutate(mvmt_data, timelag = as.numeric(difftime(lead(datetime), datetime)))

#steplength
mvmt_data <- mvmt_data %>% mutate(steplength_m = sqrt((E-lead(E))^2 + (N-lead(N))^2))

#speed
mvmt_data <- mvmt_data %>% mutate(speed_ms = steplength_m/timelag)

# Add slope
mvmt_data <- mvmt_data %>% mutate(slope = (lead(H) - H)/steplength_m * 100)

```


```{r}
# add regions
#Zurich
zh_ll <- c(2674900, 1244000)
zh_ur <- c(2692100, 1260300)

#Waadt
wt_ll <- c(2480000, 1127600)
wt_ur <- c(2575200, 1195100)

#wallis
ws_ll <- c(2538000, 1076875)
ws_ur <- c(2661500, 1153125)

mvmt_data$region <- NA
mvmt_data <- mvmt_data |> 
  mutate(
    region = case_when(
      E > zh_ll[1] & E < zh_ur[1] & N > zh_ll[2] & N < zh_ur[2] ~ 'Zurich', 
      E > wt_ll[1] & E < wt_ur[1] & N > wt_ll[2] & N < wt_ur[2] ~ 'Waadt',
      E > ws_ll[1] & E < ws_ur[1] & N > ws_ll[2] & N < ws_ur[2] ~ 'Wallis'
      )
    )
```

#### Segmentize and deal with statics points
- remove statics (ex.3)
- Add segment IDs (ex.3 - task 4)
/!\ we could use the static points for means of transport.
...

1) 
- Specify a temporal window 
- calculate average distance within the temporal window
- determine static points: choose an average distance to use as the threshold
- segmentize according to the threshold
- filter subtrajectories (length too small in time or distance for ex.)

- assign label to segment


posmo sampling rate: 10 sec
average distance to consider as static: ? slowest mean of transport is walk -> 5m?
segmentize per mean of transport?  
how to deal with tram or bus stop that we want to keep as an indicator? n° of stop in trajectory? merge the subtrajectories together?

```{r}
#specify temporal window
#60 seconds ?
#/!\ ordered and by user

#meanstep
mvmt_data <- mvmt_data |>
    mutate(
      nMinus3 = sqrt((lag(E, 3) - E)^2 + (lag(N, 3) - N)^2), #dist to pos -30s
      nMinus2 = sqrt((lag(E, 2) - E)^2 + (lag(N, 2) - N)^2), #dist to pos -20s
      nMinus1 = sqrt((lag(E, 1) - E)^2 + (lag(N, 1) - N)^2), #dist to pos -10 sec
      nPlus1  = sqrt((E - lead(E, 1))^2 + (N - lead(N, 1))^2), #dist to pos +10 sec
      nPlus2  = sqrt((E - lead(E, 2))^2 + (N - lead(N, 2))^2), #dist to pos +20 sec
      nPlus3  = sqrt((E - lead(E, 3))^2 + (N - lead(N, 3))^2) #dist to pos +30 sec
    )
mvmt_data <- mvmt_data |>
    rowwise() |>
    mutate(
        stepMean = round(mean(c(nMinus3, nMinus2, nMinus1, nPlus1, nPlus2, nPlus3)),2)
    ) |>
    ungroup()

#mean timelag
mvmt_data <- mvmt_data |>
    mutate(
      nMinus3t = as.numeric(difftime(lag(datetime, 3), datetime)), #dist to pos -30s
      nMinus2t = as.numeric(difftime(lag(datetime, 2), datetime)), #dist to pos -20s
      nMinus1t = as.numeric(difftime(lag(datetime, 1), datetime)), #dist to pos -10 sec
      nPlus1t  = as.numeric(difftime(lead(datetime, 1), datetime)), #dist to pos +10 sec
      nPlus2t  = as.numeric(difftime(lead(datetime, 2), datetime)), #dist to pos +20 sec
      nPlus3t  = as.numeric(difftime(lead(datetime, 3), datetime)) #dist to pos +30 sec
    )

mvmt_data <- mvmt_data |>
    rowwise() |>
    mutate(
        timelag_mean = round(mean(c(nMinus3t, nMinus2t, nMinus1t, nPlus1t, nPlus2t, nPlus3t)),2)
    ) |>
    ungroup()

#mean speed
mvmt_data <- mvmt_data |>
    mutate(
      nMinus3s = nMinus3/nMinus3t, #dist to pos -30s
      nMinus2s = nMinus2/nMinus2t, #dist to pos -20s
      nMinus1s = nMinus1/nMinus1t, #dist to pos -10 sec
      nPlus1s  = nPlus1/nPlus1t, #dist to pos +10 sec
      nPlus2s  = nPlus2/nPlus2t, #dist to pos +20 sec
      nPlus3s  = nPlus3/nPlus3t #dist to pos +30 sec
    )


mvmt_data <- mvmt_data |>
    rowwise() |>
    mutate(
        speed_ms_mean = round(mean(c(nMinus3s, nMinus2s, nMinus1s, nPlus1s, nPlus2s, nPlus3s)),2)
    ) |>
    ungroup()

#-> if timelag = 0 -> it means there was a record every 10 sec, which is good.


summary(mvmt_data$stepMean)
```

```{r}
#determine static points: choose an average distance to use as the threshold

#try on a sampled data
filter <- mvmt_data |>
  filter(as.Date(datetime) == "2023-04-25") %>%
  filter(is.na(tmode_manual) == FALSE)
filter

sabi <- filter |>
  ungroup() |>
  mutate(static = 
           #timelag < 5.0
           (timelag_mean > 1.0 | timelag_mean < -1.0) 
           #timelag_mean != 0.0 | 
           #is.na(timelag_mean)
         #&
           #(stepMean > 1000)
           )


#Visualisation of static / non static:
sabi_filter_static <- sabi |> filter(static)
sabi_filter_non <- sabi |> filter(!static)

sabi_filter_static_wgs <- sabi_filter_static %>% st_transform(crs = 4326)
sabi_filter_non_wgs <- sabi_filter_non%>% st_transform(crs = 4326)

m <- leaflet() %>%
  addTiles() %>%  # Add default OpenStreetMap map tiles
  addCircleMarkers(data = sabi_filter_non_wgs,
                   #opacity = 0.3,
                   radius = 0.2,
                   popup = paste(
                     "step_mean: ", sabi_filter_non_wgs$stepMean,
                     " timelag_mean: ", sabi_filter_non_wgs$timelag_mean,
                     " steplength: ", round(sabi_filter_non_wgs$steplength_m,2),
                     " timelag: ", sabi_filter_non_wgs$timelag,
                     " speed_ms: ", round(sabi_filter_non_wgs$speed_ms,2),
                     " source: ", sabi_filter_non_wgs$source
                     ),
                   color = 'blue') %>%
  addCircleMarkers(data = sabi_filter_static_wgs,
                   #opacity = 0.3,
                   radius = 0.2,
                   popup = paste(
                     "step_mean: ", sabi_filter_static_wgs$stepMean,
                     " timelag_mean: ", sabi_filter_static_wgs$timelag_mean,
                     " steplength: ", round(sabi_filter_static_wgs$steplength_m,2),
                     " timelag: ", sabi_filter_static_wgs$timelag,
                     " speed_ms: ", round(sabi_filter_static_wgs$speed_ms,2),
                     " source: ", sabi_filter_static_wgs$source
                     ),
                   color = 'red') %>%
  addLegend(position = 'topright', 
            colors = c('blue', 'red'), 
            labels = c('non static', 'static'),
            title = 'static vs non static')

# Plot the leaflet object m
m

# sabi_filter_non |>
#     ggplot(aes(E, N)) +
#     geom_path() +
#     geom_point() +
#     coord_fixed() +
#     theme(legend.position = "bottom")

```


```{r}
#Segmentize

rle_id <- function(vec) {
    x <- rle(vec)$lengths
    as.factor(rep(seq_along(x), times = x))
}

sabi <- sabi %>%
  mutate(
    segment_ID_static = rle_id(static),
    segment_ID_tmode = rle_id(tmode_manual),
    segment_ID_both = as.numeric(segment_ID_static) * as.numeric(segment_ID_tmode)
  )


#unique(sabi$segment_ID_both) %>% length()

#sabi %>% dplyr::select(c("segment_ID_static", "segment_ID_tmode")) %>% st_drop_geometry() %>% unique() %>% View()


# GROUP BY SEGMENT
sabi %>%
  group_by(source, segment_ID_both) %>% summarize() %>% View()




# VISUALISATION
n_segs <- sabi$segment_ID_both %>% unique() %>% length()
sabi_wgs <- sabi %>% st_transform(crs = 4326)

set.seed(2)
factpal <- colorFactor(sample(rainbow(n_segs)), domain =sabi_wgs$segment_ID_both)

m <- leaflet() %>%
  #addTiles() %>%  # Add default OpenStreetMap map tiles
  addProviderTiles("Esri.WorldGrayCanvas") %>%
  addCircleMarkers(data = sabi_wgs,
                   #opacity = 0.3,
                   radius = 0.2,
                   popup = paste("seg_ID: ", sabi_wgs$segment_ID_both),
                   color = ~factpal(segment_ID_both)) %>%
  addLegend(position = 'topright', 
            #colors = c('red'), 
            #labels = c('static'),
            pal = factpal,
            values = sabi_wgs$segment_ID_both,
            title = 'static vs non static')

# Plot the leaflet object m
m


# ggplot(sabi, aes(E, N, color = segment_ID)) +
#   geom_point() +
#   geom_path() +
#   coord_equal() +
#   theme(legend.position = "none") +
#   labs(subtitle = "All segments (uncleaned)")


```


#### Annotate trajectories with environment datasets
- datasets descriptions
- annotate trajectories

### Summarize characteristics of the means of transport
- Compute mean variables per segment (ex.2 task 5 (rolling windows))
-> summarize the variables by mean of transports

- general overview for each mean of transports

Summary all segments from the mean of transport:  
```{r}
#count of segments:
tmode_count <- mvmt_data %>% group_by(tmode_manual) %>% count() %>% arrange(desc(n))

knitr::kable(tmode_count %>% st_drop_geometry(),
caption = "Number of segments labelized per mode of transport")
```

```{r}
#maps per mean of transport?:

mvmt_data_filter <- mvmt_data %>% filter(tmode_manual == "walk") #%>% filter(!is.na(tmode_manual)) #%>% filter(region == "Zurich") 

mvmt_data_filter_wgs <- mvmt_data_filter %>% st_transform(crs = 4326)

m <- leaflet() %>%
  addTiles() %>%  # Add default OpenStreetMap map tiles
  addCircleMarkers(data = mvmt_data_filter_wgs,
                   #opacity = 0.3, 
                   radius = 0.2,
                   popup = mvmt_data_filter_wgs$datetime,
                   color = 'blue') %>%
  addLegend(position = 'topright', 
            colors = c('blue'), 
            labels = c('points'),
            title = 'All segments labelized as (selected)')

# Plot the leaflet object m
m

```





## Machine Learning

...

# Results
...

# Discussion
- Answer the 4 RQ

## Problems encoutered / challenges
- posmo map matching

## Limitations
...

# Conclusion
...



